
$Id: Perl-notes,v 1.4 2012-01-06 19:09:23-08 - - $

Source ideas: http://stuff.mit.edu/iap/perl/slides/slides.html

Perl summary:
- glue of the internet
- high level language
- builtin dynamic arrays and hashes
- scripting language
- no compilation needed
- powerful for text processing
- Unix system interfaces builtin
- other languages similar: Python, Ruby, Bash
- created by Larry Wall

Examples:
% perl -e 'print "hello world\n"'

% cat hello.perl
#!/usr/bin/perl
print "Hello, world!\n"

- remember to chmod +x all perl scripts
- the first line must be the hashbang

Example sieve of Eratosthenes:
- INEFFICIENT:  runs in time O(n^2)

$maximum = 1000; # $scalar
@numbers = (2..$maximum); #numbers is an @rray, create array of integers containing 2 to maximum and all in between.
while ($prime = shift @numbers) { #shift removes first thing from front of array. assigns to prime
   print $prime\n"; #is printed
   @numbers = grep {$_ % $prime != 0} @numbers; #$_ iterates all of @numbers and returns new array @numbers with multiple punched out
}






-----------------------------------------------------------------


Running perl:
create a file foo.perl using any text editor.
Make sure the first line is a hashbang:

#!/usr/bin/perl

- no white space
chmod +x foo.perl
run it with:  foo.perl
- just give its name on the command line.
- some programs will not have a suffix

If the program is non-trivial:
make sure to

use strict; #will catch spelling mistakes
- requires declaration of variables and checks on other things
use warnings; #will keep from using uninitialized variables
- prints extra warnings, specially for uninitialized variabls.




-----------------------------------------------------------------
What is true?
- anything that is not false.
What is false?
- undef, 0, ""
-----------------------------------------------------------------

# Comments start with a # character

-----------------------------------------------------------------
Data types:
scalars - singe values: strings, numbers, references. #can have pointers / references
        - types are dynamic and can change over time
arrays  - multiple values indexed by integers starting from 0
        - @a in scalar context is like a.length in Java.
        - $a[$i] is an index element #bracket array
hashes  - %h is a hash, $h{$k} is an element of a hash #braces hash
        - built into perl, so symbol table applications are easy
data structures - created by scalars, arrays, hashes of references

-----------------------------------------------------------------


Sigils: $, @, %
Identifiers are case-sensitive
Also special names: $0,    #name of script running
                    @ARGV,  #argument list
                    $_,     #'it' single thing default variable
                    $!,     # for error messgaes
                    $., 
                    $& 
-----------------------------------------------------------------
Scalars:
   $sigil                                         #int double and string are the same. 
   - may contain numbers (integer or double)
   - strings
   - references


Strings:
   - bounded by 'abc', "abc", or `abc`
   - '$abc\n' is the literal strings itself 
   - "$abc\n" is the value of the variable $abc followed by nl char
   - `time` is the output of running the command time by the shell


   concattenation; $a = $b.$c;


Local variables declared by my:
   sub foo () {
      my $a = 6; # lexically scoped as in Java
   }

$a = 6; $a = "abc"; ... type may change over time

-----------------------------------------------------------------


ARRAYS: 
   @a for a whole array
   $a[$i] for an element of an array #result of indexing an array is a $scalar
   size may change over time
   @a[$i..$j] is a slice of an array #slicing
   $a[-1] is the last element , $a[-2] second last
   $a[0] is the first element

for (my $i = 0; $i < @a: ++$i) { ... }
- when @a in scalar context, like Java a.length
for my $i (@a) { ... }
- like Java for (i: a) {...}

@a = @b is whole array assignment (copying), not reference assignment

-----------------------------------------------------------------
STACKS AND QUEUES (array with push and pop)
-----------------------------------------------------------------

$x = pop @a; removes last element assigns to $x
push @a, $x; appends $x to end of array
- stack is trivial

$x = shift @a;        removes 0 element assigns to $x
unshift @a, $x;       inserts new front element and shoves down the rest
- queue is push and shift

Also has a splice operation

With subscript, sigil changes to $ if a scalar is produced:
$a[$i] is a scalar, @a[1,10,20] is an array with element selected
$#a is usually @a - 1;


-----------------------------------------------------------------
INITIALIZING AN ARRAY
-----------------------------------------------------------------

@a = (1, 3, 5, 7, 9); - initializes an array
@a = (1..10, 101..110); - array has 20 elements in it

$a[10000] if no element returns undef

-----------------------------------------------------------------
HASHES:
-----------------------------------------------------------------

   store any number of key/value pairs
   %sigil for hash
   $h{$k} for an element
   @h{$k,$j} for an array of selected values
   @h{@a} returns an array of values indexed by elements @a

INITIALIZING:
%h = ("foo"=> 3, "bar"=> 5);        #key is foo 3, value is bar 5.
- initialized by an array with alternating key=>value pairs.
for my $key (sort keys %h) { ... $h{$key}... }

$h{$k} returns undef if not found
- undef is sort of like null in Java

delete $h{$k}; removes a key/value pair



-----------------------------------------------------------------
CONTEXT:
-----------------------------------------------------------------

- no difference between '1', "1", and 1
- auto stringifies numbers when needed, auto numifies strings
- context determines value
- context may be scalar or list.
- list==array, so *linked lists are never needed in Perl*
- $a = "33foo" + 6; sets $a to 39

String context:
- dot (.) is concatenation
- $a = 33 . 44; concatenation => 3344
- "" interpolates \escapes, $i and @a values
- @a = (1,2,3); $s="@a"; $s = '1 2 3';

Boolean context:
- undef, 0, '0', "0", "" are false; everything else is true


"19" > "9" 
19 > 9

"19" lt "9" #less than for strings
19 lt 9     #less than for strings

-----------------------------------------------------------------


OPERATORS:
   numeric, string, quoting, boolean, list

man perlop:
           left        terms and list operators (leftward)
           left        ->       #dereference
           nonassoc    ++ --
           right       **       # exponentiation
           right       ! ~ \ and unary + and -        #pattern matching operators
           left        =~ !~
           left        * / % x
           left        + - .
           left        << >>
           nonassoc    named unary operators
           nonassoc    < > <= >= lt gt le ge        # works on numbers 
           nonassoc    == != <=> eq ne cmp
           left        &
           left        | ^
           left        &&
           left        ||
           nonassoc    ..  ...
           right       ?:
           right       = += -= *= etc.
           left        , =>
           nonassoc    list operators (rightward)
           right       not
           left        and
           left        or xor

. concatenation
x repeititon:  $x = "-" x 10 means $x = "----------"
== != < <= > >= numeric operators                     #always for numbers otherwise will convert to number
eq ne lt le gt ge string operators like (strcmp)      #use for strings. 
cmp is string.compareTo
<=> is numeric.compareTo
So:  19 > 9, but "19" lt 9


-----------------------------------------------------------------
Quoting operators
-----------------------------------------------------------------
"" causes interpolation of $x scalars, @a arrays, \n, etc. escapes
'' are for literal strings only, no interp
`` interpolates passes string to shell and captures results.
$i = 6 @a = (1,2,3);
$s = '$i @a\n'; literal string
$s = "$i @a\n"; string is '6 1 2 3' followed by nl char
$s = `ls`; $s has all files in current dir.

-----------------------------------------------------------------
List operators
-----------------------------------------------------------------
push, pop, shift, unshift - see above       #splice usage is rare.
sort @a - sorts array lexicographically
sort {$a <=> $b} @a - sorts array numerically
- can use any block as first argument to sort
reverse @a - reverses the list
split /,/, $s - splits a string into an array with , as delim
join "," @a - makes a string from elements of array with , interpolated
grep {boolexpr} @a - returns a subarray for which boolexpr is true
   $_ special variable "it".
@b = grep {$_ > 0} @a; sets @b to all positive elements of @a

map {expr} @a - maps each expr onto elements of araray
@b = map {$_ * 2} @a; sets b - double of @a elements
map {$set{$_} = 1} @array - creates a hash with keys from the array
- all values are 1.  

-----------------------------------------------------------------


Flow of control:
if (expr) {stmts...}          # braces required
unless (expr) {stmts...}      # keyword that does OPPOSITE. if not stuff (if false)
if (expr) {stmts...} elsif (e) {stmts...} elsif (e) {stmts...} else{s}   #elsif like in python
- the {} on statements are required.
$a = "foo" if expr;           # put "foo" in $a if expression is true.
- can use if or unless as a suffix.

while(e){stmt...}

simple while e;       # simplestatement while e is true.

for (init; test; step) {stmt...}    # like java!

for var (list) {stmt...}
simple for $a;
print "$_\n" for 1..10; - prints out numbers 1..10;
for===foreach     #thesame lol. 
&& || !? and or - all short circuit operators.

do {stmt} until expr;
do {stmt} while expr;

next - like continue
last - like break

-----------------------------------------------------------------
Subroutines
-----------------------------------------------------------------

sub add {
   my ($a, $b) = @_;
   return $a + $b;
}
- value of sub is value of last statement or return value
- @_ is array of arguments

$a = add (3, 4);
$a = add 3, 4;
parents are not always necessary

sub update {
   my ($a) = @_;
   $$a = $$a + 1; # like C: *a = *a + 1
}
update (\$a); like C update (&a);

my $a = @a instead would set $a to the length of @_
- parens needed here

-----------------------------------------------------------------


References:
used to make compilicated data strutores.
Example trees:

$t = {LEAF=> 'a'};
- hash refernce
$u = {LEAF=> 'b');
$v = {OPER=> '+', LEFT=>$t, RIGHT=>$u};
{} makes a hash ref, [] makes an array ref.
$p = \@a; makes $p point at an array
$p->[$i] dereferences that element.
$q = \%h; address of a hash
$q->{$k} selects from the hash
No structs, so use hash references instead.

$pa = [1, 2, 3]; reference to an array
$ph = {3, 4, 5, 6}; reference to a hash
A reference is always a scalar

-----------------------------------------------------------------


FILES:

Access to files uses open and close
open my $file, "<$filename" or warn "$0: $filename: $!\n" and next;     # < for reading , > for writing.
- opens the file for reading and autovivifies the variable $file
- $! is like strerror(errno)

open my $file, ">$filename" opens it for output     # >>$filename will append to the end of existing file
close $file closes the file.

Standard files: STDIN, STDOUT, STDERR
print $a, "\n" -- uses STDOUT
print STDERR "whatever"; is like fprintf (NOTE: no comma
print $file "foo"; prints ot $file (no comma)

$a = <$file> reads a line from $file; #like readline or getLine. grabs entire line from file and returns as value of string.
- undef at EOF

while ($line = <>) {......}
reads lines from all of the files specifiedin @ARGV if any,
or STDIN if not.

while (<>) {print} #read each line from each file in sequence and then print it all out!

same as
for my $filename (@ARGV) {        
   open my $file, "<$filename" or warn "$0: $filename: $!\n" and next;          #name of script name of file error.
   while (defined (my $line = <$file>)) {
      chomp $line;                #gets rid of last character if new line character. 
      print $line, "\n";
   }
   close $file;
}

-----------------------------------------------------------------


PIPES:
open my $lsla, "ls -la |" or die "$0: ls -la: $!\n";
-- opens a pipe output from the ls -la commend.

open my $fmt, "| fmt" or die "$0: fmt: $!\n";
-- prepares FH $fmt for writing to the fmt command.

$a = `ls`; implicit pipe, stdout captured in a string
@a = `ls`; implicit pipe, each stdout line in a separate element.

File check:
if (-f $filename) - check if f is a plain file
if (-d $dir) - checks for dir.
-- see more tests in man perlop (perlfunc?)

<$f  reads
>$f  writes
>>$f append to end of that file
|$f  f must be a unix command, write into unix commands stdin 
$f|  i want to read from unix command's standard output
|$f| bad news - cause DEADLOCK. means two processes talking to each other and neither going to work. 

-----------------------------------------------------------------


Regular expressions
Pattern matching based on Chompsky's type 3 languages.

if ($a =~ m/foo/) - if $a contains the string foo
if ($a !~ m/foo/) - if $a does NOT match foo
$a =~ s/foo/bar/  - change the first occurrence of foo to bar
$a =~ s/foo/bar/g - change all occurrences of foo to bar

$0 =~ s|.*/||; delete all chars before the last /
    . match any character
    * zero or more
    ||| substituted delimiter chars
    delim char may not appear in pattern
$0 =~ s/.*\///; - same as above

Regular expressions have chars and metachars.  \ swaps the category.
\d digits [0-9], \D non-digits [^0-9]         #matches any digit, any non digit
\w word chars [a-zA-Z0-9_], \W non-word chars 
\s white space [ \t\n], \S non-whitespace
.  any char same as [^\n]
x*  zero or more x, greedy
x+  one or more x, greedy
x?  optional x, same as (x|)
x*? zero or more x, non-greedy
x+? one or more x, non-greedy
x|y indicates alternation
[xyz] means (x|y|z)
[a-z] a or z or anything in between (lexicographic order)
[^abc] any character not a or b or c
^ beginning of string
$ end of string
x{3,10} 3 to 10 x
x{4} exactly 4 x
\*, \+, \? matches the character itself


grep foo *.c will print all filed ending in .c that contain the string foo.
grep 'x.*y' *.txt  #will print out all that end in .txt
grep filestream *.st
grep FileStream *.st
grep -i filestream *.st

-----------------------------------------------------------------


Substitutions and capture.
$a =~ s/(.*), (.*), (.*)/$3, $2, $1/;
changes "abc, def, ghi" to "ghi, def, abc"

if ($date =~ m/^(\d+)\/(\d+)\/(\d+)$/) {
   my ($month, $day, $year) = ($1, $2, $3);
   my $wholedate = $&;
}

$a =~ m/$x/i; matches value of $i case insensitive
$a =~ s/abc/def/g; global substitution

